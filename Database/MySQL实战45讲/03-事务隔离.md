ACID （Atomicity、Consistency、Isolation、Durability）

原子性，一致性，隔离性，持久性



当数据库上有多个事务同时执行的时候，就可能出现**脏读**（dirty read）、**不可重复读**（non-repeatable read)、**幻读**（phantom read）的问题



为了解决这些问题有了“隔离级别”的概念



隔离的越严，效率就会越低



读未提交（read uncommited)

读提交（read commited）

可重复读（repeatable read）

串行化（serializable）



* `读未提交`是指，一个事务还没提交时，它做的**变更**就能被别的事务看到。

* `读提交`是指，一个事务提交之后，它做的变更**才**会被其他事务看到。

* `可重复读`是指，一个事务执行过程中看到的数据，总是跟这个事务在**启动时**看到的数据是一致的

* `串行化`是指，对于同一行记录，写会加写锁，读会加读锁。当出现读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。



```sql

create table T(c int) engine=InnoDB;
insert into T(c) values(1);

```

<img src="/Users/xuzheng/Projects/notes/Database/MySQL实战45讲/03-事务隔离.assets/mysql45-isolation-.png" alt="mysql45-isolation-" style=width:500px; />



 

读未提交：

* V1==2. B虽然尚未提交但也被Txn A看到了。所以V2=2， V3=2

读提交：

* V1=1，V2=2，V3=2，Txn B的更新在提交后才能被A看到。所以，V3的值也是2

可重复读：

* V1=1, V2=1, V3=2。 之所以V2 还是1，遵循的是这个要求，事务在执行期间看到的数据前后必须是一致的

串行化：

* V1和V2的值是1，V3 的值是2
* 因为隔离级别是串行化，则在事务B执行将1改成2的时候，会被锁住。直到事务A提交后，事务B才可以继续执行



在实现上，数据库里面会创建一个`视图`，访问的时候以视图的逻辑结果为准。

* 在“`可重复读`”隔离级别下，这个视图是在事务**启动**时创建的，整个事务存在期间都用这个视图。

* 在“`读提交`”隔离级别下，这个视图是在每个 `SQL 语句开始执行`的时候创建的。

* 这里需要注意的是，“`读未提交`”隔离级别下直接返回记录上的最新值，没有`视图`概念；
* 而“`串行化`”隔离级别下直接用加锁的方式来避免并行访问。



#### 如何查看当前隔离级别

```sql
show variables like 'transaction_isolation';
```



## 事务隔离的实现

每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。

假设一个值从1 被按顺序改成2、3、4. 在回滚日志里面就会有类似下面的记录![mysql45-isolation-2](/Users/xuzheng/Projects/notes/Database/MySQL实战45讲/03-事务隔离.assets/mysql45-isolation-2.png)



在查询这条记录的时候，不同**启动时刻**的事务会有不同的read-view。



同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）

什么时候删除呢？

没有其他事务线程还在使用当前版本的undo时，purge进程进行回收



索引的出现就是为了提高数据查询的效率，就像书的目录一样。

对于数据库的表而言，索引其实就是它的目录。



