1. “N叉树”的N值在MySQL中是可以被人工调整的么？



 通过改变key值来调整
N叉树中非叶子节点存放的是索引信息，索引包含Key和Point指针。Point指针固定为6个字节，假如Key为10个字节，那么单个索引就是16个字节。如果B+树中页大小为16K，那么一个页就可以存储1024个索引，此时N就等于1024。我们通过改变Key的大小，就可以改变N的值



改变页的大小
页越大，一页存放的索引就越多，N就越大。



数据页调整后，如果数据页太小层数会太深，数据页太大，加载到内存的时间和单个数据页查询时间会提高，需要达到平衡才行。





## 2. 三个范式是什么



第一范式：**字段是最小的单元不可再分**

* 学生信息组成学生信息表，有年龄、性别、学号等信息组成。这些字段都不可再分，所以它是满足第一范式的

第二范式：满足第一范式，**表中的字段必须完全依赖于全部主键而非部分主键。**

* **其他字段组成的这行记录和主键表示的是同一个东西，而主键是唯一的，它们只需要依赖于主键，也就成了唯一的**
* 学号为1024的同学，姓名为Java3y，年龄是22岁。姓名和年龄字段都依赖着学号主键。

第三范式：满足第二范式，**非主键外的所有字段必须互不依赖**

* **就是数据只在一个地方存储，不重复出现在多张表中，可以认为就是消除传递依赖**
* 比如，我们大学分了很多系（中文系、英语系、计算机系……），这个系别管理表信息有以下字段组成：系编号，系主任，系简介，系架构。那我们能不能在学生信息表添加系编号，系主任，系简介，系架构字段呢？不行的，因为这样就冗余了，非主键外的字段形成了依赖关系(依赖到学生信息表了)！正确的做法是：学生表就只能增加一个系编号字段。



## 索引是什么？

1. 一种快速查询表中内容的机制，类似于新华字典的目录
2. 运用在表中某些个字段上，但存储时，独立于表之外

索引把数据变成有序的。

快速定位到硬盘中的数据文件。



## 什么时候要创建索引

1. 表经常进行SELECT操作
2. 表很大（记录超级多），记录内容分布范围很广
3. 列名经常在WHERE子句或链接条件中出现



## 什么时候*不要*创建索引

1. 表经常进行Insert/update/delete 操作
2. 表很小（记录很少）
3. 列名不经常作为连接条件或出现在where子句中



## 索引的优缺点

* 索引**加快**数据库的检索速度
* 索引**降低**了插入、删除、修改等维护任务的速度（虽然索引可以提高查询速度，但是它们也会导致数据库系统更新数据的性能下降，因为大部分数据更新需要同时更新索引）

## 事务隔离级别

数据库定义了4个隔离级别

1. Serializable 【可避免`脏读`，不可重复读，幻读】
2. Repeatable read 【可避免`脏读`，不可重复读】
3. Read Committed 【可避免`脏读`】
4. Read uncommitted 【级别最低，什么都避免不了】

分别对应Connection类中的4个常量

1. `TRANSACTION_READ_UNCOMMITED`
2. `TRANSACTION_READ_COMMITTED`
3. `TRANSACTION_REPEATABLE_READ`
4. `TRANSACTION_SERIALIZABLE`



### 脏读

一个事务读取到另外一个事务未提交的数据

例子：A向B转账，**A执行了转账语句，但A还没有提交事务，B读取数据，发现自己账户钱变多了**！B跟A说，我已经收到钱了。A回滚事务【rollback】，等B再查看账户的钱时，发现钱并没有多。



### 不可重复读

**A查询数据库得到数据，B去修改数据库的数据，导致A多次查询数据库的结果都不一样【危害：A每次查询的结果都是受B的影响的，**



### 幻读

是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一样

注：**和不可重复读类似，但虚读(幻读)会读到其他事务的插入的数据，导致前后读取不一致**



*脏读是不可容忍的，不可重复读和虚读在一定的情况下是可以的【做统计的肯定就不行】*。



## 悲观锁和乐观锁

乐观锁和悲观锁是并发控制主要采用的技术手段

* **悲观锁**：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作
  * 在查询完数据的时候就把事务锁起来，直到提交事务
    * 实现方式：使用数据库中的`锁机制`
* **乐观锁**：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。
  * 在修改数据的时候把事务锁起来，通过**version** 的方式来进行锁定
  * 实现方式：使用version版本或时间戳



## 超键、候选键、主键、外键

* **超键**： 在关系中能唯一标识元组的属性集称为关系模式的超键。
  * 一个属性可以作为一个超键，多个属性组合在一起也可以作为一个超键。
  * 超键包含候选键和主键
* **主键**：数据库表中堆储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值
* **外键**：在一个表中存在的另一个表的主键称此表的外键。

## SQL约束有哪几种？

* NOT NULL：用于控制字段的内容一定不能为空（NULL）
* UNIQUE：控件字段内容不能重复，一个表允许有许多个UNIQUE约束
* PRIMARY KEY：也是用于控件字段内容不能重复，但它在一个表只允许出现一个。
* FOREIGN KEY：用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。
* CHECK： 用于控制字段的值范围



## MySQL常见存储引擎

**InnoDB引擎**：InnoDB引擎提供了堆数据库ACID事务的支持。并且还提供了行级锁和外键。

**MyIASM**：不提供事务的支持，也不支持行级锁和外键

**MEMORY引擎**：所有的数据都在内存中，数据的处理速度快，但安全性不高。



## 数据库优化思路

### SQL优化

1. 选择最有效率的表名顺序

数据库的解析器按照**从右到左**的顺序处理FROM子句中的表名，FROM子句中写在最后的表将被最先处理





## MySQL索引有哪些 都有什么作用

### 主键索引（Primary， pk_)

必须为主键字段创建一个索引，这个Mysql索引就是所谓的`“主索引”`。

一般情况下，数据库的主键为依次递增的`uuid`。这样可以在插入的时候，加快建立`索引`的速度。



### 普通索引（Normal，idx_）

**普通索引**（由关键字KEY或INDEX定义的索引）的唯一任务是加快对数据的访问速度。因此，应该只为那些最经常出现在查询条件（`WHERE`column=）或排序条件（`ORDERBY`column）中的数据列创建索引。
根据MySQL引擎(`InnoDB`或者`MyISAM` )不同，非主键索引的工作方式不同。

- **InnoDB**是聚集索引，非主键索引存放的是主键索引的值
- **MyISAM**是非聚集索引，非主键索引存放的是数据的地址



### 唯一索引（Unique，uk_)

如果能确定某个数据列将只包含彼此**各不相同**的值，在为这个数据列创建索引的时候就应该用关键字UNIQUE把它定义为一个唯一索引。

这么做的好处：

* 一是简化了MySQL对这个索引的管理工作，这个索引也因此而变得更有效率；
* 二是MySQL会在有新记录插入数据表时，自动检查新记录的这个字段的值是否已经在某个记录的这个字段里出现过了；如果是，MySQL将拒绝插入那条新记录。

也就是说，**唯一索引**可以保证数据记录的唯一性。事实上，在许多场合，人们创建唯一索引的目的往往不是为了提高访问速度，**而只是为了避免数据出现重复。**
比如我想要一个userId对应数据库中的一条记录，那么可以跟userId建立唯一索引



### 全文索引（FullText）

仅可用于 `MyISAM` 表， 用于在一篇文章中，检索文本信息的, 针对较大的数据，生成全文索引很耗时好空间。
不过 `FULLTEXT` 用于搜索很长一篇文章的时候，效果最好。
用在比较短的文本，如果就一两行字的，普通的 INDEX 也可以。
比如有一个字段是备注，可能查找的时候，会把这个备注当做条件，那么可以在这个备注上面做**全文索引**.



主键索引：`pk_`

唯一索引：`uk_`

普通索引：`idx_`

