```
半机翻
```



# 封面

Go正在迅速成为构建Web服务的首选语言。有很多教程可以向有其他编程语言经验的开发人员教授Go的语法。但是教程还不够。它们没有教授Go的习惯用语，因此开发人员最终会重新创建在Go上下文中没有意义的模式。本实用指南为您提供了编写清晰和习惯的Go语言所需的基本背景知识。

无论你的经验水平如何，你都会学会如何像Go开发者那样思考。作者 Jon Bodner 揭示了有经验的 Go 开发者所采用的设计模式及其原理。你将学会如何构建你的项目，选择合适的工具和库来创建成功的软件。

学习如何在Go中编写习惯性代码，设计一个Go项目。
理解Go中设计决策的原因。
为一个单独的开发者或团队建立一个Go开发环境。
了解如何以及何时使用反思、不安全和CGo。
了解 Go 的功能如何让语言高效运行。
了解哪些Go功能您应该少用或不用。
了解Go的未来，包括通用技术

# 第二章 基本类型与声明



是时候开始研究Go语言的功能以及如何**最好地**使用他们了。当试图找出“最好”的含义时，有一个首要的原则：以一种能够明确你的意图的方式来编写你的程序。当我们了解功能的时候，我们会看看其他选择，我会解释为什么我发现一种特定的方法能产生更清晰的代码。



我们先来看看**基本类型**和**变量**。虽然每个程序员对这些概念都有经验，但Go对一些事情的处理方式是不同的，Go和其他语言之间有微妙的区别。

## 内置类型 （Built-in types)

Go有许多与其他语言相同的内置类型：布尔运算、整数、浮点数和字符串。idiomatically使用这些类型对于从其他语言过渡过来的开发人员来说有时是一个挑战。我们将研究这些类型，看看它们在Go中如何发挥最佳作用。

### 零值 （The zero value）

在C或者C++中，一个未初始化的变量得到一个未定义值。 就像大多数现代语言，Go给声明了但未赋值的变量赋于zero value。拥有一个显式的零值可以是代码更清晰，并消除了C和C++程序中的错误来源。

每种类型都有一个零值。一个类型的零值可以看作是此类型的默认值。

- 一个布尔类型的零值表示真假中的假。
- 数值类型的零值都是零（但是不同类型的零在内存中占用的空间可能不同）。
- 一个字符串类型的零值是一个空字符串。

### 显式类型转换

Go不允许变量之间的自动类型提升。当变量类型不匹配时，你必须用类型转换（type conversion）

```go
var x int = 10
var y float64 = 30.2
var z float64 = float64(x) + y
var d int = x + int(y)
```

Go要求类型完全匹配；在接下来的章节中，我们将看到Go有**不同大小**的整数和浮点类型。这些不同大小的整数和浮点数必须转换为相同的类型才能进行交互。



### 字面量

Go中的字面量指写出一个数字、字符或是字符串。在Go中，你会发现四种常用的字面量。

*整数字面量*是数字的序列。0b for binary （base-2）， 0o for octal（base-8）， 0x for hexadecimal （base-16）。后面没有字母的前导0是另一种表示八进制文字的方式❌。不要使用它，因为它很容易引起混淆。为了让阅读比较长的整数字面量更方便。Go允许你在字面量中间加入下划线 `1_234`。

```go
0xF // 十六进制表示（必须使用0x或者0X开头）
0XF

017 // 八进制表示（必须使用0、0o或者0O开头）❌
0o17
0O17

0b1111 // 二进制表示（必须使用0b或者0B开头）
0B1111

15  // 十进制表示（必须不能用0开头）
```



*浮点型字面量*

*Rune字面量表示字符*，被单引号包围。与许多语言不同，单引号和双引号是不能互换的。实际上，使用10进制来表示你的数字字面量，除非上下文让你的代码更清晰，否则尽量避免使用任何十六进制转义来表示符文字面量。

```go
'\141'   // 141是97的八进制表示
'\x61'   // 61是97的十六进制表示
'\u0061' // \u之后必须跟随四个十六进制数字字符表示一个rune值（此rune值的高四位都为0
'\U00000061'
```

八进制表示很少见，大多数用来表示POSIX权限标志值（如0o777表示rwxrwxrwx）。十六进制和二进制有时用于位过滤器或网络和基础设施应用。

有两种不同的方式来表示字符串字面量。大部分时间双引号来给出一个解释型字符串字面量（Interpreted String Literal）。这种包含0个或者多个rune字面量。另一种是raw stirng literal，反引号风格

```go
// 解释形式
"Greetings and\n\"Salutations\""

// raw
`Greetings and
"Salutations"`
```

我们之前看到Go是一个坚持类型的语言；如果两个整型变量是不同的大小，你甚至不能将他们加在一起。然而，Go让你在浮点表达式中使用整数字面量，甚至讲一个整数字面量赋值给一个浮点变量。这是因为字面量在Go中是无类型的。他们可以与任何与字面量兼容的变量进行交互. they can interact with any variable that’s compatible with the literal.

```go
var f float64 = 42
fmt.Println(reflect.TypeOf(f)) // float64
fmt.Println(f)									// 42
fmt.Println(reflect.TypeOf(42)) // int

var f2 float64 = 42.2
fmt.Println(reflect.TypeOf(f2))	// float64
fmt.Println(f2)									// 42.2
fmt.Println(reflect.TypeOf(42.2)) // float64
```

[Go Playground](https://play.golang.org/p/VqOXSvtke28)

当我们在第七章看到用户自定义类型时将会看到，我们甚至可以在基本类型的基础上使用用户定义类型的字面量。但是这种“untyped”只能到此为止了。你不能将字符串字面量复制给数字变量，或者不能将数字字面量复制给字符串变量，也不能将浮点型字面量赋值给整型。

（也就是42赋值给float可以， 42.2 赋值给int不可以）

正如您在变量赋值一节中所看到的那样，在 Go 中，有些情况下类型并没有被明确声明。在这些情况下，Go 使用默认的类型来表示一个字符；如果表达式中没有明确说明字符的类型，那么字符默认为一个类型。我们在研究不同的内置类型时，会提到文字的默认类型。

### Booleans

bool 类型表示布尔变量。bool类型的变量有两个值：true或false。bool类型的零值是false。

因为所有类型转换在Go中都是显式的，所以你不能用另外一种类型当作布尔类型。在许多语言中，数字，字符串甚至指针都是truthy值；如果一个数字是非负的，一个字符串是非空的，或者一个指针指向一些有意义的，你可以把他们当作真值。但Go不允许这样。**实际上，没有其他类型能转变成布尔类型，不管是显式还是隐式**。如果你想从其他数据类型转换为布尔型，你必须使用比较操作符（comparison operators)。



### Numeric Types

A `byte` is an alias for `uint8`.

`rune`是`int32`的内置别名。

On a 32-bit CPU, `int` is a 32 bit signed integer like `int32`. On most 64-bit CPUs, `int` is a 64-bit signed integer, just like an `int64`. 

#### 选择哪种Integer来用

这里有三个原则：

* 如果你正在处理的二进制文件格式或网络协议具有特定大小或符号的整数，请使用相应的整数类型。
* 如果你写的库函数应该适用于任何整数类型，请写一对函数，一个用int64作为参数和变量，另一个用uint64。(我们在第5章中更多地谈论函数及其参数)。
* 其他情况下，只需用int



Go中的浮点与其他语言中的浮点类似。Go使用IEEE 754规范，使其范围较大，精度有限。挑选使用哪种浮点类型是很直接的：除非你必须与现有的格式兼容，否则使用float64。浮点字面量的默认类型为float64，所以始终使用float64可以避免类型转换和显式类型声明。

Warning：浮点数不能准确地表示十进制值。不要用它们来表示货币或任何其他必须用***精确***的十进制表示的数值。

如果你指的是一个**字符**，请使用 rune 类型，而不是 int32 类型。对编译器来说，它们可能是一样的，但你要使用能明确代码意图的类型。

#### var VS :=

有一些情况你应该避免使用`:=`

* 当初始化一个变量为其零值时，使用 `var x int`。这就明确了想要零值的目的
* 当将一个无类型常量或字面量赋值给一个变量，而常量或字面量的默认类型并不是我们想要的类型时, 使用var 形式
* 因为 := 允许您对新的和现有的变量进行赋值，所以有时当你认为你在重复使用现有的变量时，它其实是在创建新的变量。在这些情况下，用var显式声明所有的新变量，以明确哪些变量是新的，然后使用赋值操作符（=）为新变量和旧变量赋值。

虽然var和:=允许你在同一行声明多个变量，但只有在分配从函数返回的多个值或逗号ok的idiom时才使用这种风格。

你应该尽可能少的在函数之外声明变量（也就是package block）。改变包级别变量的值是一个坏主意。当你在函数之外有一个变量时，你很难追踪对一个变量所做的改变。这会导致理解数据如何在程序中流动变得困难。这回导致一些微妙的bug。作为一般规则，你应该只在包块中声明有效的**不可变**的变量。

#### using const

Go中的const与其他语言的const完全不同。Go的常量是给字面量命名的一种方式。它们只能持有编译器在编译时能计算出来的值。

