# Chapter 1 Object-Oriented Design



这个世界也是面向对象的。与你互动的对象可能包括配偶和一只猫，或者一辆旧车和车库里的一堆自行车零件，或者你滴答作响的心脏和你用来保持它健康的运动计划。这些对象中的每一个都配备了自己的行为，虽然它们之间的一些互动可能是可以预测的，但你的配偶完全有可能出乎意料地踩到猫，引起反应，使大家的心率迅速提高，并让你对自己的运动计划有新的认识。



在一个对象的世界里，新的行为安排自然而然地出现了。你不需要为 spouse_steps_on_cat 过程明确地写出实现，你只需要一个会走路的配偶对象和一个不喜欢被踩的猫对象。把这两个对象一起放到一个房间里，就会出现意想不到的行为组合。



本书是关于设计面向对象的软件，以及如何将世界看作是一系列对象之间自发的交互。面向对象设计(OOD)要求你从把世界看作是预定义程序的集合，转变为把世界建模为对象之间传递的一系列消息。OOD的失败看似是编码技术的失败，但实际上是perspective上的失败。

（perspective， 思考方法，态度，观点，角度）

学习如何进行面向对象设计的首要条件是让自己沉浸在对象中，一旦掌握了面向对象的观点，其他的就会自然而然地跟上。

本书指导你完成沉浸的过程。本章首先对OOD进行了一般性讨论。它论证了设计的理由，然后继续描述何时进行设计以及如何判断设计。本章最后简要概述了面向对象编程，定义了本书中使用的术语。



## 1.1 In Praise of Design

搭建一个软件是有原因的。目标软件是全部的重点，不论它是一个琐碎的游戏，还是一个指导放射治疗的程序。

If painful programming were the most cost-effective way to produce working software, programmers would be morally obligated to suffer stoically or to find other jobs.

如果痛苦的编程是打造工作软件的最具成本效益的方式，那么程序员在道德上就有义务忍受痛苦，或者寻找其他工作。

幸运的是，你不必在快乐和生产力之间做出选择。让写代码成为一种乐趣的编程技术与最有效地生产软件的编程技术是重合的。

面向对象设计的技术既解决了程序设计的道德困境，又解决了技术困境。

### 1.1.1 设计解决的问题

不幸的是，事情将会改变。它总是这样。客户不知道他们想要什么，他们没有说出他们的意思。你并不了解他们的需求

其中最糟糕的渐渐变成了个人恐怖片，你出演一个不幸的程序员，疯狂地从一个旋转的盘子跑到下一个盘子，试图抵挡餐具碰撞的声音。



### 1.1.2 Why Change Is Hard

面向对象的应用程序是由部件组成的，这些部件相互作用，产生整体的行为。这些部件是对象；交互体现在它们之间传递的消息中。要把正确的消息传递到正确的目标对象，需要消息的发送者知道关于接收者的事情。这种知识在两者之间产生了**依赖**，而这些**依赖**阻碍了变化。



Object-oriented design is about managing dependencies. 面向对象设计就是管理依赖关系。

它是一组安排依赖关系的编码技巧，这样对象可以容忍变化。

在没有设计的情况下，无管理的依赖性会造成严重的破坏，因为对象之间相互了解太多。改变一个对象迫使其合作者改变，而合作者又反过来迫使其合作者改变，无穷无尽。

设计不良的小应用的问题是，如果它们成功了，它们就会成长为设计不良的大应用。

它们渐渐变成了你不敢踩的柏油坑，免得你沉沦得无影无踪。

本应简单的更改可能会级联到应用程序的方方面面，到处破坏代码，需要大量的重写。测试被夹在中间，并开始成为阻碍而不是帮助。



### 1.1.3 A practical Definition of Design

设计不是一条流水线，在那里，训练有素的工人构造出相同的小部件；它是一个工作室，在那里，志同道合的艺术家雕刻出定制的应用程序。因此，设计是一门**艺术**，是安排代码的**艺术**。



设计的部分困难在于，每个问题都有两个组成部分。

1. 你不仅要为你今天计划交付的功能编写代码，
2. 还必须创建可供日后修改的代码。



因为设计原则是**重叠的**，而且每个问题都涉及到**时间框架**的变化，所以设计挑战可能有很多**令人困惑**的解决方案。

你的工作是综合(synthesis)；你必须将对应用需求的整体理解与对设计备选方案的成本和收益的了解结合起来，然后设计出一种在当前具有成本效益并在未来继续具有成本效益的代码安排。

:exclamation: 实用的设计并不预测你的应用会发生什么；它只是接受一些事情会发生，而且，在现在，你无法知道是什么。它不猜测未来；它为你保留了适应未来的选择。==它不是选择，而是给你留下行动的空间==。



设计的目的是允许你之后还可以设计，其主要目标是降低变更的成本。



## 1.2 The Tools of Design

设计并不是遵循一套固定规则的行为，而是沿着一条分支路径的旅程，在这条路径上，先前的选择关闭了一些选项，并打开了通往其他选项的通道。

在设计过程中，你会在需求的迷宫中游走，每一个关口都代表着一个决策点，对未来有影响。

Just as a sculptor has chisels and files, an object-oriented designer has tools -- **principles and patterns**.



The principles of good design represent measurable truths, and following them will improve your code.



然而，模式的流行导致了新手程序员对模式的滥用，他们在过度的善意的热情下，将完全好的模式应用到错误的问题上。

本书不是关于模式的，然而，它将为你理解模式做好准备，并给你选择和适当使用模式所必需的知识。

## 1.3 The Act of Design



### 1.3.1 How Design Fails

设计失败的**第一种**方式是由于缺乏设计。程序员最初对设计知之甚少。然而，这并不妨碍他们，因为在不了解设计的情况下，也可以制作出可行的应用程序。

任何OO语言都是如此，但有些语言比其他语言更容易受到影响，像Ruby这样平易近人的语言尤其容易受到影响。

然而，成功的但未设计的应用程序携带着自己毁灭的种子；它们很容易写，但逐渐变得无法改变。程序员过去的经验并不能预测未来。早期的无痛开发承诺逐渐失效，乐观主义变成了绝望，因为程序员开始用 "是的，我可以添加这个功能，但它会破坏一切 "来迎接每一个更改请求。



第二种：

稍微有经验的程序员会遇到不同的设计失败。这些程序员知道OOD技术，但还不明白如何应用。

They construct complicated, beautiful castles of code and then are distressed to find themselves hemmed in by stone walls.

他们建造了复杂而美丽的代码城堡，然后苦恼地发现自己被石墙包围了。

You can recognize these programmers because they begin to greet change requests with “No, I can’t add that feature; it wasn’t designed to do that.”

你可以识别这些程序员，因为他们开始用 "不，我不能添加这个功能，它的设计不是这样的 "来迎接变更请求。



敏捷开发可以让设计定期调整，自然发展。当设计是由远处的人决定的时候，必要的调整都无法发生，早期的理解失败会被固化在代码中。程序员被迫编写由孤立的专家设计的应用程序，他们开始说："好吧，我当然可以写出这个，但这不是你真正想要的，你最终会后悔的。"



但是，敏捷说 "不要做大的前期设计"，并不代表它叫你完全不做设计。设计这个词在BUFD中使用的时候和在OOD中使用的时候意义是不一样的。

BUFD就是要完全明确和完全记录所提出的应用的所有功能的预期未来的内部运作。

如果有软件架构师参与，这可能会延伸到提前决定如何安排所有的代码。

OOD关注的是一个更窄的领域。它是关于安排你所拥有的代码，使其易于改变。

敏捷流程保证了变化**，而你做出这些变化的能力取决于你的应用程序的设计**。

如果你不能写出精心设计的代码，你将不得不在每次迭代中重写你的应用程序。



因此，敏捷并不禁止设计，而是需要设计。它不仅需要设计，还需要真正的好设计。它需要你最好的工作。它的成功依赖于简单、灵活、可塑性强的代码。



SLOC (source lines of code) says nothing about overall quality.

OOD metrics cannot identify designs that do the wrong thing in the right way.

OOD metrics 无法识别用正确的方式做错事的设计。

它们并不是质量的直接指标，而是更深层次衡量的代用指标。

The ultimate software metric would be ==**cost per feature over the time interval that matters**==, but this is not easy to calculate. **Cost**, **feature**, and **time** are individually difficult to define, track, and measure.

即使你可以隔离一个单独的功能，并跟踪其所有相关的成本，重要的时间间隔也会影响如何判断代码。有时，现在拥有该功能的价值是如此之大，以至于它超过了未来任何成本的增加。如果缺乏一个功能会迫使你今天失去业务，那么明天处理代码的成本就不重要了，你必须在你拥有的时间内做到最好。

做出这种设计上的妥协就像向未来借时间，被称为承担技术债务。这是一笔最终需要偿还的贷款，很有可能是连本带利的。



即使你不是有意承担技术债务，设计也需要时间，因此也要花钱。因为你的目标是以最低的每项功能成本来编写软件，你决定做多少设计取决于两点：你的技术和你的时间框架。如果设计花了你这个月一半的时间，而且一年内都没有开始回报，那可能就不值得了。当设计的行为阻碍了软件的按时交付，你就输了。交付一半精心设计的应用程序可能和没有交付应用程序是一样的。但是，如果设计今天上午花了你一半的时间，今天下午就把时间还回来了，然后在应用程序的生命周期内继续提供好处，你就会得到一种每天复利的时间；这种设计努力永远得到回报。

