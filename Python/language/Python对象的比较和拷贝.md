## `is` 和 `==`

// ankitodo

Q: == 用来比较什么?

A: '=='操作符比较对象之间的值是否相等

Q: is 用来比较什么?

A: is 用来比较两个对象的地址是否相等

Q: 可变对象有哪些?

A: 列表, 字典, 集合等

Q: 不可变对象有哪些?

A: 字符串, 整型, 元组





Python 内部会对 -5 到 256 的整型维持一个数组，起到一个缓存的作用
比较操作符'is'的速度效率，通常要优于'=='

'is'操作符不能被重载，这样，Python 就不需要去寻找，程序中是否有其他地方重载了比较操作符，并去调用。执行比较操作符'is'，就仅仅是比较两个变量的 ID 而已。



但是'=='操作符却不同，执行a == b相当于是去执行`a.__eq__(b)`，而 Python 大部分的数据类型都会去重载`__eq__`这个函数，其内部的处理通常会复杂一些。

```python
t1 = (1, 2, [3, 4])
t2 = (1, 2, [3, 4])
t1 == t2
True
t1[-1].append(5)
t1 == t2
False
```



元组是不可变的, 但元组可以嵌套, 里面的元素是列表时, 这个列表时可以变的



## 深拷贝 和 浅拷贝

```python

l1 = [1, 2, 3]
l2 = list(l1)
# l2 就是l1的浅拷贝
l2
[1, 2, 3]

l1 == l2
True

l1 is l2
False

s1 = set([1, 2, 3])
s2 = set(s1)

s2
{1, 2, 3}

s1 == s2
True

s1 is s2
False
```



// ankitodo

### shadow copy

浅拷贝，是指重新分配一块内存，创建一个新的对象，里面的元素是原对象中子对象的引用。，因此，如果原对象中的元素是可变的，改变其也会影响拷贝后的对象，存在一定的副作用。

### Deep copy

深度拷贝，是指重新分配一块内存，创建一个新的对象，并且将原对象中的元素，以递归的方式，通过创建新的子对象拷贝到新对象中。因此，新对象和原对象没有任何关联。

深度拷贝则会递归地拷贝原对象中的每一个子对象，因此拷贝后的对象和原对象互不相关。另外，深度拷贝中会维护一个字典，记录已经拷贝的对象及其 ID，来提高效率并防止无限递归的发生。



## 注意

1、对于非容器类型，如数字、字符，以及其他的“原子”类型，没有拷贝一说，产生的都是原对象的引用。
2、如果元组变量值包含原子类型对象，即使采用了深拷贝，也只能得到浅拷贝。



* 变量的赋值，只是表示让变量指向了某个对象，并不表示拷贝对象给变量；

* 而一个对象，可以被多个变量所指向。
* 可变对象（列表，字典，集合等等）的改变，会影响所有指向该对象的变量。
* 对于不可变对象（字符串、整型、元组等等），所有指向该对象的变量的值总是一样的，也不会改变。但是通过某些操作（+= 等等）更新不可变对象的值时，会返回一个新的对象。
* 变量可以被删除，但是对象无法被删除。



Python的参数传递是**赋值传递** (pass by assignment), 或者叫做**对象的引用传递(pass by object reference)**
Python里的所有数据类型都是对象, 所以参数传递时, 只是让新变量与原变量指向相同的对象而已, 并不存在值传递或引用传递



 ```python

def my_func4(l2):
  l2 = l2 + [4]

l1 = [1, 2, 3]
my_func4(l1)
l1
[1, 2, 3]
 ```

这里 l2 = l2 + [4]，==表示创建了一个“末尾加入元素 4“的新列表，并让 l2 指向这个新的对象==。这个过程与 l1 无关，因此 l1 的值不变



> 一种是直接将可变数据类型（比如列表，字典，集合）当作参数传入，直接在其上修改；第二种则是创建一个新变量，来保存修改后的值，然后将其返回给原变量。在实际工作中，我们更倾向于使用后者，因为其表达清晰明了，不易出错。



列表是可变对象, 每创建一个列表, 都会重新分配内存