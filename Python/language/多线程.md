# Python 多线程
单核实现并发效果。

## 必备知识点

* 并发
	* 看起来像同时运行的
* 并行
	* 真正意义上的同时运行。

## 同步和异步
* 描述的是任务的提交方式
* 被调用方. 消息通信机制

* 同步：任务提交之后，原地等待任务的返回结果，等待的过程中不做任何事（干等）。**程序层面**表现出来的感觉是卡住了。
* 异步：任务提交后，不原地等待任务的返回结果，直接做其他事 。有一个回调机制。
	* 任务的返回结果会有一个异步回调机制自动处理

## 阻塞和非阻塞
* 描述程序的运行状态
  阻塞：阻塞态
  非阻塞：就绪态，运行态
* 调用方

**最高效的**：*异步非阻塞*

## 开启进程的方式
windows系统下，创建进程一定要在main内创建，因为windows下创建进程类似于模块导入的方式，会从上往下依次执行代码。循环导入
要有
`if __name__ == '__main__':`


*容器类型哪怕里面只有一个元素，建议一定要逗号隔开*

join方法
join方法是让主进程等待子进程代码运行结束之后，再继续运行。不影响其他子进程的执行。	

## GIL全局解释器 

global interpreter lock

CPython解释器中GIL是一把互斥锁，用来组织同一个进程下的多个线程同时执行（同一个进程下的多个线程无法利用多核优势）

内存管理
1. 应用计数
2. 标记清楚
3. 分代回收
#### 重点
1. GIL不是python的特点，是CPython解释器的特点
2. GIL是保证解释器级别的数据的安全
3. GIL会导致同一个进程下的多个线程无法同时执行（无法利用多核优势）
4. 针对不同的数据还是需要加不同的锁处理
5. 解释型语言的通病： 同一个进程下多个线程无法利用多核优势

`time.sleep(0,1)`只要进入了IO GIL会自动释放

## 那Python同一个进程下的多线程是否有用？

### 多线程是否有用要看具体情况
#### 单核：四个任务（IO密集型or计算密集型）

#### 多核：四个任务（IO密集型or计算密集型）

#### 计算密集型 每个任务都要10s
单核： 多进程：没用

多核：
*多进程：总耗时10s+*
多线程： 总耗时 40+
#### IO密集型 每个任务10s
多核：
多进程：相对浪费资源
多线程：更加节省资源
IO密集型情况下，多进程和多线程都没有什么优势，多线程消耗资源更少。


## reentrant lock RLock
可重入

可以被连续的acquire和release
但是只能被第一个抢到这把锁执行上述操作
它的内部有一个计数器，每a一次计数加一 每r一次计数减一
只要计数不为0，那么其他人都无法抢到锁

